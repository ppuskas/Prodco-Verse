<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prodco-Verse ‚Äî Boutique AI Mapper</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Inter', -apple-system, sans-serif;
            overflow: hidden;
        }

        /* ‚îÄ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: linear-gradient(180deg, rgba(10, 10, 15, 0.95) 0%, rgba(10, 10, 15, 0) 100%);
            padding: 20px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #header h1 {
            font-size: 22px;
            font-weight: 800;
            background: linear-gradient(135deg, #6ee7b7, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #header .stats {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: #888;
        }

        #header .stats span {
            background: rgba(255, 255, 255, 0.06);
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        #header .stats .num {
            color: #6ee7b7;
            font-weight: 700;
        }

        /* ‚îÄ‚îÄ‚îÄ Legend ‚îÄ‚îÄ‚îÄ */
        #legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(15, 15, 25, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            backdrop-filter: blur(12px);
        }

        #legend h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 10px;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .legend-line {
            width: 20px;
            height: 2px;
            flex-shrink: 0;
            border-radius: 1px;
        }

        /* ‚îÄ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ‚îÄ */
        #tooltip {
            position: fixed;
            z-index: 200;
            pointer-events: none;
            background: rgba(15, 15, 25, 0.95);
            border: 1px solid rgba(110, 231, 183, 0.3);
            border-radius: 10px;
            padding: 12px 16px;
            backdrop-filter: blur(16px);
            display: none;
            max-width: 280px;
        }

        #tooltip .tt-name {
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 4px;
        }

        #tooltip .tt-type {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #6ee7b7;
        }

        #tooltip .tt-meta {
            font-size: 11px;
            color: #888;
            margin-top: 6px;
        }

        /* ‚îÄ‚îÄ‚îÄ Filter Panel ‚îÄ‚îÄ‚îÄ */
        #filters {
            position: fixed;
            top: 70px;
            right: 20px;
            z-index: 100;
            background: rgba(15, 15, 25, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            backdrop-filter: blur(12px);
        }

        #filters h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 10px;
        }

        #filters label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            margin-bottom: 6px;
            cursor: pointer;
        }

        #filters input[type="checkbox"] {
            accent-color: #6ee7b7;
        }

        #filters select {
            width: 100%;
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 12px;
        }

        svg {
            width: 100vw;
            height: 100vh;
        }

        /* ‚îÄ‚îÄ‚îÄ Track Agency Panel ‚îÄ‚îÄ‚îÄ */
        #plant-panel {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 100;
            background: rgba(15, 15, 25, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            backdrop-filter: blur(12px);
            width: 240px;
        }

        #plant-panel h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 10px;
        }

        #plant-panel input {
            width: 100%;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
            margin-bottom: 8px;
            outline: none;
            transition: border-color 0.2s;
        }

        #plant-panel input:focus {
            border-color: rgba(110, 231, 183, 0.5);
        }

        #plant-panel input::placeholder {
            color: #555;
        }

        .btn-plant {
            width: 100%;
            padding: 8px;
            background: linear-gradient(135deg, #6ee7b7, #3b82f6);
            border: none;
            border-radius: 6px;
            color: #000;
            font-weight: 700;
            font-size: 13px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .btn-plant:hover {
            opacity: 0.9;
        }

        .btn-plant:disabled {
            opacity: 0.4;
            cursor: wait;
        }

        .btn-scrape {
            width: 100%;
            padding: 8px;
            background: linear-gradient(135deg, #fb7185, #f59e0b);
            border: none;
            border-radius: 6px;
            color: #000;
            font-weight: 700;
            font-size: 13px;
            cursor: pointer;
            margin-top: 10px;
            transition: opacity 0.2s;
        }

        .btn-scrape:hover {
            opacity: 0.9;
        }

        .btn-scrape:disabled {
            opacity: 0.4;
            cursor: wait;
        }

        #plant-status {
            font-size: 11px;
            color: #6ee7b7;
            margin-top: 8px;
            min-height: 16px;
        }

        .gap-badge {
            display: inline-block;
            background: rgba(251, 113, 133, 0.2);
            color: #fb7185;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        /* ‚îÄ‚îÄ‚îÄ Back link ‚îÄ‚îÄ‚îÄ */
        .back-link {
            text-decoration: none;
            font-size: 13px;
            font-weight: 600;
            color: #6ee7b7;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .back-link:hover {
            opacity: 1;
        }

        /* ‚îÄ‚îÄ‚îÄ Progress Bar ‚îÄ‚îÄ‚îÄ */
        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #f59e0b, #fb7185);
            transition: width 0.3s ease;
        }
    </style>
</head>

<body>
    <div id="header">
        <h1>üó∫Ô∏è Prodco-Verse</h1>
    </div>

    <div id="plant-panel">
        <h3>üö© Track Agency</h3>
        <input type="text" id="plant-agency" placeholder="Agency Name...">
        <input type="text" id="plant-project" placeholder="Founder / Note (optional)">
        <button class="btn-plant" id="btn-plant" onclick="plantFlag()">üö© Track Agency</button>
        <div id="plant-status"></div>
        <hr style="border: none; border-top: 1px solid rgba(255,255,255,0.1); margin: 12px 0;">
        <h3>üéØ Select Target</h3>
        <div id="gap-info" style="font-size: 11px; color: #888; margin-bottom: 8px;">Click a node to target...</div>
        <button class="btn-scrape" id="btn-scrape" onclick="scrapeTarget()" disabled>üöÄ Scrape Target</button>
        <button class="btn-scrape" id="btn-discover" onclick="discoverSimilar()" disabled
            style="margin-top: 8px; background: #6366f1;">üåê Discover Similar</button>
        <div id="scrape-progress-container" class="progress-container">
            <div id="scrape-progress-bar" class="progress-bar"></div>
        </div>
    </div>

    <div id="legend">
        <h3>Nodes</h3>
        <div class="legend-row">
            <div class="legend-dot" style="background: #f59e0b; box-shadow: 0 0 8px #f59e0b;"></div> Landmark
        </div>
        <div class="legend-row">
            <div class="legend-dot" style="background: #6ee7b7;"></div> agency
        </div>
        <div class="legend-row">
            <div class="legend-dot" style="background: #3b82f6;"></div> project
        </div>
        <div class="legend-row">
            <div class="legend-dot" style="background: #a78bfa;"></div> traditional
        </div>
        <div class="legend-row">
            <div class="legend-dot" style="background: #fb7185;"></div> person
        </div>
        <h3 style="margin-top: 12px;">Edges</h3>
        <div class="legend-row">
            <div class="legend-line" style="background: #6ee7b7;"></div> founder
        </div>
        <div class="legend-row">
            <div class="legend-line" style="background: #3b82f6;"></div> alumni
        </div>
        <div class="legend-row">
            <div class="legend-line" style="background: #a78bfa;"></div> partner
        </div>
        <div class="legend-row">
            <div class="legend-line" style="background: #f59e0b;"></div> collaborator
        </div>
        <div class="legend-row">
            <div class="legend-line" style="background: #fb7185;"></div> notable
        </div>
    </div>

    <div id="filters">
        <div class="stats" id="stats-bar"
            style="margin-bottom: 12px; font-size: 11px; display: flex; flex-direction: column; gap: 4px;"></div>
        <h3>Show Nodes</h3>
        <label><input type="checkbox" checked data-type="agency"> Agencies <span id="count-agency"
                style="color:#888; font-size:10px;">(0)</span></label>
        <label><input type="checkbox" data-type="project"> Projects <span id="count-project"
                style="color:#888; font-size:10px;">(0)</span></label>
        <label><input type="checkbox" checked data-type="traditional"> Traditionals <span id="count-traditional"
                style="color:#888; font-size:10px;">(0)</span></label>
        <label><input type="checkbox" checked data-type="person"> People <span id="count-person"
                style="color:#888; font-size:10px;">(0)</span></label>
        <h3 style="margin-top: 12px;">Focus Landmark</h3>
        <select id="landmark-select">
            <option value="">All Landmarks</option>
        </select>
    </div>

    <div id="tooltip">
        <div class="tt-name"></div>
        <div class="tt-type"></div>
        <div class="tt-meta"></div>
    </div>

    <svg></svg>

    <script>
        let currentTargetNode = null;
        let isViewOnly = false;

        const NODE_COLORS = {
            agency: '#6ee7b7',
            project: '#3b82f6',
            traditional: '#a78bfa',
            person: '#fb7185'
        };

        const EDGE_COLORS = {
            founder: '#6ee7b7',
            alumni: '#3b82f6',
            partner: '#a78bfa',
            collaborator: '#f59e0b',
            notable: '#fb7185'
        };

        const NODE_RADIUS = {
            agency: 8,
            project: 3,
            traditional: 5,
            person: 7
        };

        async function init() {
            // View Only Mode Check
            if (window.location.hostname.includes('vercel.app')) {
                isViewOnly = true;
                const header = document.querySelector('#header h1');
                header.innerHTML += ' <span style="font-size: 12px; color: #fb7185; vertical-align: middle; margin-left:8px; border:1px solid #fb7185; padding:2px 6px; border-radius:4px; letter-spacing:1px;">VIEW ONLY</span>';

                document.getElementById('plant-panel').style.opacity = '0.6';
                document.getElementById('btn-plant').disabled = true;
                document.getElementById('btn-plant').textContent = 'DISABLED (Vercel)';
                document.querySelectorAll('#plant-panel input').forEach(i => i.disabled = true);
            }

            const res = await fetch('/api/mapper/graph');
            const graph = await res.json();

            // Stats bar
            const statsBar = document.getElementById('stats-bar');
            statsBar.innerHTML = `
            <span><span class="num">${graph.landmarks.length}</span> landmarks</span>
            <span><span class="num">${Object.keys(graph.nodes).length}</span> nodes</span>
            <span><span class="num">${graph.edges.length}</span> edges</span>
        `;

            // Populate landmark dropdown
            const landmarkSelect = document.getElementById('landmark-select');
            graph.landmarks.forEach(l => {
                const opt = document.createElement('option');
                opt.value = l.name;
                opt.textContent = l.name;
                landmarkSelect.appendChild(opt);
            });

            // ‚îÄ‚îÄ‚îÄ Dynamic Counts ‚îÄ‚îÄ‚îÄ
            function updateFilterCounts() {
                const counts = { agency: 0, project: 0, traditional: 0, person: 0 };
                Object.values(graph.nodes).forEach(n => {
                    if (counts[n.type] !== undefined) counts[n.type]++;
                });
                for (const [type, count] of Object.entries(counts)) {
                    const el = document.getElementById(`count-${type}`);
                    if (el) el.textContent = `(${count})`;
                }
            }
            updateFilterCounts();

            // Convert graph to D3 format
            const nodeMap = {};
            const nodes = [];
            const visibleTypes = new Set(['agency', 'traditional', 'person']); // projects hidden by default (820 is heavy)

            for (const [key, data] of Object.entries(graph.nodes)) {
                const node = { id: key, ...data };
                node.radius = data.isLandmark ? 16 : (NODE_RADIUS[data.type] || 4);

                // Highlight viral/notable project nodes
                if (data.type === 'project' && (data.isViral || data.isNotable)) {
                    node.radius += 3;
                    node.color = '#f59e0b';
                } else {
                    node.color = data.isLandmark ? '#f59e0b' : (NODE_COLORS[data.type] || '#555');
                }

                // Gap detection: unmapped agencys render as hollow
                node.isUnmapped = (data.type === 'agency' && data.mapStatus === 'unmapped');
                nodeMap[key] = node;
                nodes.push(node);
            }

            const links = graph.edges
                .filter(e => nodeMap[e.from] && nodeMap[e.to])
                .map(e => ({
                    source: e.from,
                    target: e.to,
                    axis: e.axis,
                    weight: e.weight,
                    color: EDGE_COLORS[e.axis] || '#333'
                }));

            // SVG setup
            const width = window.innerWidth;
            const height = window.innerHeight;
            const svg = d3.select('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g');

            // Zoom
            const zoom = d3.zoom()
                .scaleExtent([0.1, 8])
                .on('zoom', (event) => g.attr('transform', event.transform));
            svg.call(zoom);

            // Initial zoom out to fit
            svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(0.4));

            // Force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(d => {
                    if (d.axis === 'partner') return 30;
                    if (d.axis === 'founder') return 80;
                    return 60;
                }).strength(d => d.weight * 0.3))
                .force('charge', d3.forceManyBody().strength(d => d.isLandmark ? -400 : -20))
                .force('center', d3.forceCenter(0, 0))
                .force('collision', d3.forceCollide().radius(d => d.radius + 2))
                .alphaDecay(0.02);

            // Draw edges
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', d => d.color)
                .attr('stroke-opacity', 0.15)
                .attr('stroke-width', d => Math.max(0.3, d.weight));

            // Draw nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => d.radius)
                .attr('fill', d => d.isUnmapped ? 'transparent' : d.color)
                .attr('stroke', d => d.isLandmark ? '#f59e0b' : d.isUnmapped ? '#fb7185' : 'none')
                .attr('stroke-width', d => d.isLandmark ? 3 : d.isUnmapped ? 2 : 0)
                .attr('stroke-dasharray', d => d.isUnmapped ? '3,2' : 'none')
                .attr('opacity', d => visibleTypes.has(d.type) || d.isLandmark ? 1 : 0.05)
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', (e, d) => { if (!e.active) simulation.alphaTarget(0.1).restart(); d.fx = d.x; d.fy = d.y; })
                    .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
                    .on('end', (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
                );

            // Glow effect for landmarks
            node.filter(d => d.isLandmark)
                .attr('filter', 'url(#glow)');

            // SVG filter for glow
            const defs = svg.append('defs');
            const filter = defs.append('filter').attr('id', 'glow');
            filter.append('feGaussianBlur').attr('stdDeviation', '4').attr('result', 'coloredBlur');
            const feMerge = filter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // Add stars for viral nodes
            const viralNodes = nodes.filter(d => d.isViral || d.isNotable);
            const stars = g.append('g')
                .selectAll('text')
                .data(viralNodes)
                .join('text')
                .text('‚≠ê')
                .attr('font-size', '16px')
                .attr('text-anchor', 'middle')
                .attr('dy', '5px')
                .style('pointer-events', 'none')
                .style('text-shadow', '0 0 6px rgba(0,0,0,0.9)');

            // Labels for landmarks + agencys with many connections
            const labelNodes = nodes.filter(d => d.isLandmark || (d.type === 'agency' && d.connections > 3));
            const labels = g.append('g')
                .selectAll('text')
                .data(labelNodes)
                .join('text')
                .text(d => d.name)
                .attr('font-size', d => d.isLandmark ? '13px' : '9px')
                .attr('font-weight', d => d.isLandmark ? '800' : '500')
                .attr('fill', d => d.isLandmark ? '#f59e0b' : '#ccc')
                .attr('text-anchor', 'middle')
                .attr('dy', d => -(d.radius + 6))
                .style('pointer-events', 'none')
                .style('text-shadow', '0 0 6px rgba(0,0,0,0.9)');

            // Tooltip & Click Actions
            const tooltip = document.getElementById('tooltip');
            let hideTimeout;

            node.on('mouseover', (event, d) => {
                clearTimeout(hideTimeout);
                tooltip.style.display = 'block';
                tooltip.style.pointerEvents = 'auto'; // allow clicking links

                tooltip.querySelector('.tt-name').textContent = d.name || d.id;

                let typeHtml = d.type + (d.isLandmark ? ' ¬∑ LANDMARK' : '');
                if (d.source === 'agent') {
                    typeHtml += ' ü§ñ Agent Secured';
                }
                tooltip.querySelector('.tt-type').textContent = typeHtml;

                let metaHtml = '';
                if (d.bio) metaHtml += `<div style="color: #e2e8f0; margin-bottom: 6px; line-height: 1.3;">${d.bio}</div>`;
                if (d.url) {
                    metaHtml += `<div style="margin-bottom: 6px;"><a href="${d.url}" target="_blank" style="color: #6ee7b7; text-decoration: underline;">Visit Project ‚Üó</a></div>`;
                }

                const metaArr = [];
                if (d.connections) metaArr.push(`Links: ${d.connections}`);

                let linksHtml = '';
                if (d.linkedIn) linksHtml += `<a href="${d.linkedIn}" target="_blank" style="color: #3b82f6; text-decoration: none; margin-right: 8px;">in</a>`;
                if (d.twitter) linksHtml += `<a href="${d.twitter}" target="_blank" style="color: #1da1f2; text-decoration: none;">ùïè</a>`;

                if (linksHtml) {
                    metaHtml += `<div style="margin-top: 6px; font-weight: bold;">${linksHtml}</div>`;
                }

                if (metaArr.length > 0) {
                    metaHtml += `<div style="margin-top: 6px; color: #888;">${metaArr.join(' ¬∑ ')}</div>`;
                }

                tooltip.querySelector('.tt-meta').innerHTML = metaHtml;

                // Highlight connections
                const connectedIds = new Set();
                links.forEach(l => {
                    const src = typeof l.source === 'object' ? l.source.id : l.source;
                    const tgt = typeof l.target === 'object' ? l.target.id : l.target;
                    if (src === d.id) connectedIds.add(tgt);
                    if (tgt === d.id) connectedIds.add(src);
                });
                node.attr('opacity', n => n.id === d.id || connectedIds.has(n.id) ? 1 : 0.08);
                link.attr('stroke-opacity', l => {
                    const src = typeof l.source === 'object' ? l.source.id : l.source;
                    const tgt = typeof l.target === 'object' ? l.target.id : l.target;
                    return src === d.id || tgt === d.id ? 0.6 : 0.03;
                });
            })
                .on('mousemove', (event) => {
                    // Position tooltip slightly off cursor so we can hover it
                    tooltip.style.left = (event.clientX + 16) + 'px';
                    tooltip.style.top = (event.clientY - 10) + 'px';
                })
                .on('mouseout', (event) => {
                    // Slight delay to allow moving mouse into tooltip to click links
                    hideTimeout = setTimeout(() => {
                        tooltip.style.display = 'none';
                    }, 500);
                    node.attr('opacity', d => visibleTypes.has(d.type) || d.isLandmark ? 1 : 0.05);
                    link.attr('stroke-opacity', 0.15);
                });

            // Prevent tooltip from disappearing when hovering over it
            tooltip.addEventListener('mouseenter', () => clearTimeout(hideTimeout));
            tooltip.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });

            // Node Selection & Target Actions
            node.on('click', async (event, d) => {
                if (event.defaultPrevented) return; // Dragged, ignore

                currentTargetNode = d;
                const btn = document.getElementById('btn-scrape');
                const btnDiscover = document.getElementById('btn-discover');
                const gapInfo = document.getElementById('gap-info');

                // Briefly style the node to show it's selected
                node.attr('stroke', n => n.id === d.id ? '#fff' : (n.isLandmark ? '#f59e0b' : (n.isUnmapped ? '#fb7185' : 'none')))
                    .attr('stroke-width', n => n.id === d.id ? 4 : (n.isLandmark ? 3 : (n.isUnmapped ? 2 : 0)))
                    .attr('stroke-dasharray', n => n.id === d.id ? '4,4' : (n.isUnmapped ? '3,2' : 'none'));

                if (isViewOnly) {
                    btn.disabled = true;
                    btn.textContent = 'DISABLED (View Only)';
                    gapInfo.innerHTML = `üéØ Selected: <strong style="color:#fff">${d.name}</strong><br/><span style="color:#fb7185">Interactive scraping disabled on Vercel.</span>`;
                } else {
                    btn.disabled = false;
                    btn.textContent = `üöÄ Scrape from ${d.name}`;

                    if (d.type === 'agency') {
                        btnDiscover.disabled = false;
                        btnDiscover.textContent = `üåê Discover ${d.name} Competitors`;
                    } else {
                        btnDiscover.disabled = true;
                        btnDiscover.textContent = `üåê Discover Similar`;
                    }
                    gapInfo.innerHTML = `üéØ Target Selected: <strong style="color:#fff">${d.name}</strong><br/><span style="color:#6ee7b7">Type: ${d.type}</span>`;
                }
            });

            // Tick
            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                node.attr('cx', d => d.x).attr('cy', d => d.y);
                labels.attr('x', d => d.x).attr('y', d => d.y);
                stars.attr('x', d => d.x).attr('y', d => d.y);
            });

            // ‚îÄ‚îÄ‚îÄ Seamless Graph Update (Phase 4) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            window.refreshGraphData = async function () {
                const res = await fetch('/api/mapper/graph');
                const newGraph = await res.json();

                // Update Stats
                document.getElementById('stats-bar').innerHTML = `
                <span><span class="num">${newGraph.landmarks.length}</span> landmarks</span>
                <span><span class="num">${Object.keys(newGraph.nodes).length}</span> nodes</span>
                <span><span class="num">${newGraph.edges.length}</span> edges</span>
                `;

                // Update Nodes
                let newNodesCount = 0;
                const counts = { agency: 0, project: 0, traditional: 0, person: 0 };

                for (const [key, data] of Object.entries(newGraph.nodes)) {
                    if (counts[data.type] !== undefined) counts[data.type]++;

                    if (!nodeMap[key]) {
                        const n = { id: key, ...data };
                        n.radius = data.isLandmark ? 16 : (NODE_RADIUS[data.type] || 4);
                        if (data.type === 'project' && (data.isViral || data.isNotable)) {
                            n.radius += 3;
                            n.color = '#f59e0b';
                        } else {
                            n.color = data.isLandmark ? '#f59e0b' : (NODE_COLORS[data.type] || '#555');
                        }
                        n.isUnmapped = (data.type === 'agency' && data.mapStatus === 'unmapped');

                        // Spawn new nodes slightly offset from target
                        if (currentTargetNode) {
                            n.x = currentTargetNode.x + (Math.random() - 0.5) * 20;
                            n.y = currentTargetNode.y + (Math.random() - 0.5) * 20;
                        }
                        nodeMap[key] = n;
                        nodes.push(n);
                        newNodesCount++;
                    } else {
                        nodeMap[key].isUnmapped = (data.type === 'agency' && data.mapStatus === 'unmapped');
                    }
                }

                for (const [type, count] of Object.entries(counts)) {
                    const el = document.getElementById(`count-${type}`);
                    if (el) el.textContent = `(${count})`;
                }

                if (newNodesCount === 0) return; // Nothing new

                // Update Edges
                const existingLinks = new Set(links.map(l => {
                    const src = l.source.id || l.source;
                    const tgt = l.target.id || l.target;
                    return `${src}->${tgt}->${l.axis}`;
                }));

                newGraph.edges.forEach(e => {
                    if (!existingLinks.has(`${e.from}->${e.to}->${e.axis}`) && !existingLinks.has(`${e.to}->${e.from}->${e.axis}`) && nodeMap[e.from] && nodeMap[e.to]) {
                        links.push({
                            source: nodeMap[e.from],
                            target: nodeMap[e.to],
                            axis: e.axis,
                            weight: e.weight,
                            color: EDGE_COLORS[e.axis] || '#333'
                        });
                    }
                });

                // Rebind DOM - Links
                link = g.selectAll('line').data(links, d => {
                    const src = d.source.id || d.source;
                    const tgt = d.target.id || d.target;
                    return `${src}->${tgt}->${d.axis}`;
                })
                    .join('line')
                    .attr('stroke', d => d.color)
                    .attr('stroke-opacity', 0.15)
                    .attr('stroke-width', d => Math.max(0.3, d.weight));

                // Rebind DOM - Nodes
                node = g.selectAll('circle').data(nodes, d => d.id)
                    .join('circle')
                    .attr('r', d => d.radius)
                    .attr('fill', d => d.isUnmapped ? 'transparent' : d.color)
                    .attr('stroke', d => d.isLandmark ? '#f59e0b' : d.isUnmapped ? '#fb7185' : 'none')
                    .attr('stroke-width', d => d.isLandmark ? 3 : d.isUnmapped ? 2 : 0)
                    .attr('stroke-dasharray', d => d.isUnmapped ? '3,2' : 'none')
                    .attr('opacity', d => visibleTypes.has(d.type) || d.isLandmark ? 1 : 0.05)
                    .style('cursor', 'pointer')
                    .call(d3.drag()
                        .on('start', (e, d) => { if (!e.active) simulation.alphaTarget(0.1).restart(); d.fx = d.x; d.fy = d.y; })
                        .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
                        .on('end', (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
                    );

                // Filters and Glows
                node.filter(d => d.isLandmark).attr('filter', 'url(#glow)');

                // Rebind DOM - Stars
                const viralNodes = nodes.filter(d => d.isViral || d.isNotable);
                stars = g.selectAll('text.star').data(viralNodes, d => d.id)
                    .join('text')
                    .attr('class', 'star')
                    .text('‚≠ê')
                    .attr('font-size', '16px')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '5px')
                    .style('pointer-events', 'none')
                    .style('text-shadow', '0 0 6px rgba(0,0,0,0.9)');

                // Rebind DOM - Labels
                const labelNodes = nodes.filter(d => d.isLandmark || (d.type === 'agency' && d.connections > 3));
                labels = g.selectAll('text.label').data(labelNodes, d => d.id)
                    .join('text')
                    .attr('class', 'label')
                    .text(d => d.name)
                    .attr('font-size', d => d.isLandmark ? '13px' : '9px')
                    .attr('font-weight', d => d.isLandmark ? '800' : '500')
                    .attr('fill', d => d.isLandmark ? '#f59e0b' : '#ccc')
                    .attr('text-anchor', 'middle')
                    .attr('dy', d => -(d.radius + 6))
                    .style('pointer-events', 'none')
                    .style('text-shadow', '0 0 6px rgba(0,0,0,0.9)');

                // Restart simulation gently
                simulation.nodes(nodes);
                simulation.force('link').links(links);
                simulation.alpha(0.3).restart();
            };

            // ‚îÄ‚îÄ‚îÄ Filter handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            document.querySelectorAll('#filters input[type="checkbox"]').forEach(cb => {
                cb.addEventListener('change', () => {
                    const type = cb.dataset.type;
                    if (cb.checked) visibleTypes.add(type);
                    else visibleTypes.delete(type);
                    node.attr('opacity', d => visibleTypes.has(d.type) || d.isLandmark ? 1 : 0.05);
                    node.attr('r', d => visibleTypes.has(d.type) || d.isLandmark ? d.radius : 1);
                });
            });

            landmarkSelect.addEventListener('change', () => {
                const selected = landmarkSelect.value;
                if (!selected) {
                    node.attr('opacity', d => visibleTypes.has(d.type) || d.isLandmark ? 1 : 0.05);
                    link.attr('stroke-opacity', 0.15);
                    return;
                }

                // Find the landmark node key
                const lmKey = Object.keys(graph.nodes).find(k =>
                    graph.nodes[k].name?.toLowerCase() === selected.toLowerCase() && graph.nodes[k].isLandmark
                );
                if (!lmKey) return;

                // Find all connected
                const connected = new Set([lmKey]);
                graph.edges.forEach(e => {
                    if (e.from === lmKey) connected.add(e.to);
                    if (e.to === lmKey) connected.add(e.from);
                });

                node.attr('opacity', d => connected.has(d.id) ? 1 : 0.04);
                link.attr('stroke-opacity', l => {
                    const src = typeof l.source === 'object' ? l.source.id : l.source;
                    const tgt = typeof l.target === 'object' ? l.target.id : l.target;
                    return connected.has(src) && connected.has(tgt) ? 0.5 : 0.02;
                });
            });
        }

        // ‚îÄ‚îÄ‚îÄ Track Agency ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function plantFlag() {
            if (isViewOnly) return;
            const agency = document.getElementById('plant-agency').value.trim();
            const project = document.getElementById('plant-project').value.trim();
            if (!agency) return;
            const btn = document.getElementById('btn-plant');
            const status = document.getElementById('plant-status');
            btn.disabled = true;
            btn.textContent = '‚è≥ Mapping...';
            try {
                const res = await fetch('/api/mapper/agency', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ agency, project: project || undefined })
                });
                const data = await res.json();
                if (data.success) {
                    status.innerHTML = `‚úÖ Successfully mapped ${agency}.`;
                    setTimeout(() => location.reload(), 2000);
                } else {
                    status.textContent = `‚ùå ${data.error}`;
                }
            } catch (err) {
                status.textContent = `‚ùå ${err.message}`;
            }
            btn.disabled = false;
        }

        // Enter key to plant
        document.getElementById('plant-agency').addEventListener('keydown', e => {
            if (e.key === 'Enter') plantFlag();
        });

        // ‚îÄ‚îÄ‚îÄ Scrape Target ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function scrapeTarget() {
            if (isViewOnly || !currentTargetNode) return;
            const target = currentTargetNode;
            const btn = document.getElementById('btn-scrape');
            const gapInfo = document.getElementById('gap-info');
            const progressContainer = document.getElementById('scrape-progress-container');
            const progressBar = document.getElementById('scrape-progress-bar');

            btn.disabled = true;
            btn.textContent = '‚è≥ Launching Agent...';
            progressContainer.style.display = 'block';
            progressBar.style.width = '50%';

            try {
                const res = await fetch('/api/mapper/scrape-node', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: target.id, type: target.type, name: target.name })
                });
                const data = await res.json();
                progressBar.style.width = '100%';
                if (data.added > 0) {
                    gapInfo.innerHTML = `<span style="color:#6ee7b7">‚úÖ Secured ${data.added} nodes.</span>`;
                    const projectCb = document.querySelector('input[data-type="project"]');
                    if (projectCb && !projectCb.checked) {
                        projectCb.checked = true;
                        projectCb.dispatchEvent(new Event('change'));
                    }
                }
                setTimeout(async () => {
                    progressContainer.style.display = 'none';
                    if (window.refreshGraphData) await window.refreshGraphData();
                    else location.reload();
                }, 2000);
            } catch (err) {
                gapInfo.innerHTML = `<span style="color:#fb7185">‚ùå Error: ${err.message}</span>`;
                btn.disabled = false;
            }
        }

        // ‚îÄ‚îÄ‚îÄ Discover Similar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function discoverSimilar() {
            if (isViewOnly || !currentTargetNode) return;
            const target = currentTargetNode;
            const btn = document.getElementById('btn-discover');
            const progressContainer = document.getElementById('scrape-progress-container');
            const progressBar = document.getElementById('scrape-progress-bar');

            btn.disabled = true;
            progressContainer.style.display = 'block';
            progressBar.style.width = '70%';

            try {
                const res = await fetch('/api/mapper/discover-similar', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: target.id, name: target.name })
                });
                const data = await res.json();
                progressBar.style.width = '100%';
                setTimeout(async () => {
                    progressContainer.style.display = 'none';
                    if (window.refreshGraphData) await window.refreshGraphData();
                    else location.reload();
                }, 2000);
            } catch (err) {
                btn.disabled = false;
            }
        }

        init();
    </script>
</body>

</html>